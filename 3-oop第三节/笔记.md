## 面向对象oop
 - 受保护的封装 protected
   - 受保护的封装进行一定级别的封装，
   - 在类中或者子类中可以访问，
   - 外部不能访问
 - 语法：
   - 在成员名称前添加下划线 _age = 55
 - 公开的 public
   - 公共的成员，可以在任何地方访问 age = 55
   
## 继承
 ### 继承的作用：减少代码，增加代码复用功能，同时可以设置类和类之间的关系，便于维护
 - 例如：详见例子1  
 - 继承和被继承的关系：
   - 被继承的叫父类、基类、超类
   - 继承的叫子类
   - 继承和被继承有一个叫is-a的关系
 - 继承的特征：
   - 子类一旦继承父类，既可以使用父类中除私有成员外的所有内容
   - 子类继承父类后并没有将父类成员完全赋值到子类中，而是通过引用关系调用
   - 子类中可以定义独有的成员属性和方法
   - 如果子类中定义的成员和父类成员相同，优化使用子类成员
   - 子类如果想扩充父类的方法，可以定义新方法的同时，也可以扩充父类的方法
     - 语法：
        - 1、父类名.父类成员
        - 2、super().父类成员
 - 继承变量函数的查找顺序问题
   - 优先查找自己的变量
   - 没有则查找父类
   - 构造函数的查找：
     - 如果自己没有定义，则查找父类构造函数
     - 如果本类有定义，则不再继续向上查找
 - 构造函数
   - 是一类特殊的函数，在类进行实例化之前调用，用于类的初始化
   - 如果类定义了构造函数，则查找自己的构造函数
   - 如果没定义，则一级一级向上查找父类构造函数，直达找到为止
   - 调用哪一级的构造函数，就应该按照该类的参数传值
 - super()方法: super()方法返回的是一个代理父类对象
   - super不是父类，而是代表得到父类，不是关键字，而是一个类
   - super的作用是获取MRO列表中的第一个类
   - super对于父类没有任何实质性关系，但通过super可以调用到父类
   - super使用场景：
     - 可以在子类中调用父类的构造方法：super().method()
 -- mro方法(详见例子3)
   - ( --mro--) :
     -- 实际上是对继承树做层序遍历的结果, 
        把一棵带有结构的树变成了一个线性的表, 
        所以沿着这个列表一直往上, 就可以无重复的遍历完整棵树, 
        也就解决了多继承中的Diamond问题.
   
 